import { _ as _export_sfc, c as createElementBlock, o as openBlock, a4 as createStaticVNode, a7 as _imports_0 } from "./chunks/framework.CfygL32k.js";
const __pageData = JSON.parse('{"title":"Request / Response","description":"","frontmatter":{},"headers":[],"relativePath":"shuttle-esb/concepts/patterns/request-response.md","filePath":"shuttle-esb/concepts/patterns/request-response.md"}');
const _sfc_main = { name: "shuttle-esb/concepts/patterns/request-response.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="request-response" tabindex="-1">Request / Response <a class="header-anchor" href="#request-response" aria-label="Permalink to &quot;Request / Response&quot;">â€‹</a></h1><p>For some background on <strong>Request/Response</strong> messaging pattern you can have a look at the <a href="http://en.wikipedia.org/wiki/Request-response" target="_blank" rel="noreferrer">Wikipedia article</a>.</p><p><img src="' + _imports_0 + '" alt="Request/Response Image"></p><p>To request an endpoint to perform a certain function you send a command message:</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SendAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RequestMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>Although this is a very simple pattern it results in rather tight behavioural coupling. This is not necessarily a bad thing and in many instances it is definitely required.</p><p>Typically the message handler for the command message goes about its business and processes the message. But there will be times when a response is required.</p><p>The response can then be a command message or an event message and you can simply call the <strong>reply</strong> method on the service bus instance:</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SendAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ResponseMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">builder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> builder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Reply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>The response may, of course, be decoupled by publishing an event message but it is up to the implementor to decide the mechanism. This would then no longer be request/response but rather publish/subscribe. The advantage of request/response is that it provides the ability to respond to the caller directly whereas publishing a message would result in <strong>all</strong> publishers receiving a copy of the message.</p><p>All message sending in Shuttle.Esb is uni-directional. This means that a message will be displatched to the receipient queue where is will be processed by a message handler. That message handler can then decide whether to respond by sending another message back (uni-directional) to the sender&#39;s work queue, or perhaps publish an event, or even do nothing.</p>', 11);
const _hoisted_12 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_12);
}
const requestResponse = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  requestResponse as default
};
