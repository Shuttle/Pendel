import{_ as a,c as r,j as e,a as s,o}from"./chunks/framework.C4Vvvhxx.js";const n="/images/streaming.png",g=JSON.parse('{"title":"Stream Processing","description":"","frontmatter":{},"headers":[],"relativePath":"shuttle-esb/concepts/patterns/stream-processing.md","filePath":"shuttle-esb/concepts/patterns/stream-processing.md"}'),i={name:"shuttle-esb/concepts/patterns/stream-processing.md"};function m(c,t,d,l,p,u){return o(),r("div",null,t[0]||(t[0]=[e("h1",{id:"stream-processing",tabindex:"-1"},[s("Stream Processing "),e("a",{class:"header-anchor",href:"#stream-processing","aria-label":'Permalink to "Stream Processing"'},"â€‹")],-1),e("p",null,[s("With message streaming events are produced in a continuous stream that isn't targeted at any specific consumers. The streams are typically divided into topics and consumers can read messages from a topic. Consumers are usually identified as a logical unit using some form of discriminator. Topcis may also be partitioned and one would have at "),e("em",null,"most"),s(" the number of consumers as there are partitions.")],-1),e("p",null,"The number of messages kept in the stream is determined by a retention policy and consumers may start processing messages from any point in the stream; although typically either the oldest/earliest/tail or most recent/newest/head would be used as a starting point. Messages are, therefore, not removed once consumed but are rather removed once the retention policy determines that they are no longer required. The policy is usually either a period or a maximum size for the stream, or a combination of period and size. This is in contrast to a queue where a message is targeted at a particular logical endpoint and once processed the message is removed.",-1),e("p",null,[e("img",{src:n,alt:"Streaming Image"})],-1)]))}const f=a(i,[["render",m]]);export{g as __pageData,f as default};
